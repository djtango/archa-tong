// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Belt_Option from "bs-platform/lib/es6/belt_Option.js";
import * as Caml_format from "bs-platform/lib/es6/caml_format.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Caml_builtin_exceptions from "bs-platform/lib/es6/caml_builtin_exceptions.js";

function timeLeft(currentTime, endTime) {
  return endTime - currentTime;
}

function calcEndTime(startTime, duration) {
  return startTime + duration;
}

function setTimeLeft(state) {
  var start = Belt_Option.getWithDefault(state.currentTime, state.timerStartTime);
  var end_ = state.timerStartTime + state.durationInput;
  return {
          durationInput: state.durationInput,
          timerStartTime: state.timerStartTime,
          currentTime: state.currentTime,
          timeLeft: end_ - start,
          intervalId: state.intervalId
        };
}

function startClock(dispatch) {
  return Caml_option.some(setInterval((function (param) {
                    return Curry._1(dispatch, /* GetCurrentTime */2);
                  }), 30));
}

function stopClock(intervalId) {
  Belt_Option.map(intervalId, (function (prim) {
          clearInterval(prim);
          
        }));
  
}

function businessLogic(state, action) {
  if (typeof action === "number") {
    switch (action) {
      case /* Noop */0 :
          return /* tuple */[
                  state,
                  /* IODoNothing */0
                ];
      case /* Stop */1 :
          return /* tuple */[
                  {
                    durationInput: -1.0,
                    timerStartTime: state.timerStartTime,
                    currentTime: state.currentTime,
                    timeLeft: state.timeLeft,
                    intervalId: state.intervalId
                  },
                  /* IOStopTimer */Block.__(1, [state.intervalId])
                ];
      case /* GetCurrentTime */2 :
          return /* tuple */[
                  state,
                  /* IOGetCurrentTime */1
                ];
      case /* SetTimeLeft */3 :
          throw [
                Caml_builtin_exceptions.match_failure,
                /* tuple */[
                  "Model.re",
                  61,
                  39
                ]
              ];
      
    }
  } else {
    switch (action.tag | 0) {
      case /* Start */0 :
          return /* tuple */[
                  state,
                  /* IOStartTimer */Block.__(0, [action[0]])
                ];
      case /* SetDuration */1 :
          return /* tuple */[
                  {
                    durationInput: Caml_format.caml_float_of_string(action[0]),
                    timerStartTime: state.timerStartTime,
                    currentTime: state.currentTime,
                    timeLeft: state.timeLeft,
                    intervalId: state.intervalId
                  },
                  /* IODoNothing */0
                ];
      case /* SetTimer */2 :
          return /* tuple */[
                  {
                    durationInput: state.durationInput,
                    timerStartTime: action[1],
                    currentTime: state.currentTime,
                    timeLeft: state.timeLeft,
                    intervalId: action[0]
                  },
                  /* IODoNothing */0
                ];
      case /* SetCurrentTime */3 :
          return /* tuple */[
                  setTimeLeft({
                        durationInput: state.durationInput,
                        timerStartTime: state.timerStartTime,
                        currentTime: action[0],
                        timeLeft: state.timeLeft,
                        intervalId: state.intervalId
                      }),
                  /* IODoNothing */0
                ];
      
    }
  }
}

function runEffect(effect) {
  if (typeof effect === "number") {
    if (effect === /* IODoNothing */0) {
      return /* Noop */0;
    } else {
      return /* SetCurrentTime */Block.__(3, [Date.now()]);
    }
  } else if (effect.tag) {
    return /* SetTimer */Block.__(2, [
              stopClock(effect[0]),
              -1.0
            ]);
  } else {
    return /* SetTimer */Block.__(2, [
              startClock(effect[0]),
              Date.now()
            ]);
  }
}

function wrapBusinessLogicWithEffects(f, _state, _action) {
  while(true) {
    var action = _action;
    var state = _state;
    var match = Curry._2(f, state, action);
    var effect = match[1];
    var newState = match[0];
    if (effect === /* IODoNothing */0) {
      return /* tuple */[
              newState,
              /* Noop */0
            ];
    }
    var nextAction = runEffect(effect);
    _action = nextAction;
    _state = newState;
    continue ;
  };
}

var initState = {
  durationInput: -1.0,
  timerStartTime: -1.0,
  currentTime: undefined,
  timeLeft: undefined,
  intervalId: undefined
};

export {
  initState ,
  timeLeft ,
  calcEndTime ,
  setTimeLeft ,
  startClock ,
  stopClock ,
  businessLogic ,
  runEffect ,
  wrapBusinessLogicWithEffects ,
  
}
/* No side effect */
