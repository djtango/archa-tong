// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Belt_Float from "bs-platform/lib/es6/belt_Float.js";
import * as Belt_Option from "bs-platform/lib/es6/belt_Option.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";

function setDuration(state, input) {
  return /* tuple */[
          {
            durationInput: input,
            timerStartTime: state.timerStartTime,
            currentTime: state.currentTime,
            timeLeft: state.timeLeft,
            intervalId: state.intervalId
          },
          /* IODoNothing */0
        ];
}

function timeLeft(currentTime, endTime) {
  return endTime - currentTime;
}

function calcEndTime(startTime, duration) {
  return startTime + duration;
}

function pure_(x) {
  return Caml_option.some(x);
}

function apply(optionF, optionO) {
  if (optionF !== undefined && optionO !== undefined) {
    return Caml_option.some(Curry._1(optionF, Caml_option.valFromOption(optionO)));
  }
  
}

function lift2(f, oA, oB) {
  return apply(apply(Caml_option.some(f), oA), oB);
}

var $$Option = {
  pure_: pure_,
  apply: apply,
  lift2: lift2
};

function setTimeLeft(state) {
  var currentTime = state.currentTime;
  var timerStartTime = state.timerStartTime;
  var duration = Belt_Float.fromString(state.durationInput);
  var start = Belt_Option.map(timerStartTime, (function (param) {
          return Belt_Option.getWithDefault(currentTime, param);
        }));
  var end_ = lift2(calcEndTime, timerStartTime, duration);
  return {
          durationInput: state.durationInput,
          timerStartTime: state.timerStartTime,
          currentTime: state.currentTime,
          timeLeft: lift2(timeLeft, start, end_),
          intervalId: state.intervalId
        };
}

function startClock(dispatch) {
  return Caml_option.some(setInterval((function (param) {
                    return Curry._1(dispatch, /* GetCurrentTime */2);
                  }), 30));
}

function stopClock(intervalId) {
  Belt_Option.map(intervalId, (function (prim) {
          clearInterval(prim);
          
        }));
  
}

function setTimeLeft$1(state, t) {
  var newState = setTimeLeft({
        durationInput: state.durationInput,
        timerStartTime: state.timerStartTime,
        currentTime: t,
        timeLeft: state.timeLeft,
        intervalId: state.intervalId
      });
  return /* tuple */[
          newState,
          /* IOCheckIfTimerFinished */Block.__(2, [newState.timeLeft])
        ];
}

function businessLogic(state, action) {
  if (typeof action === "number") {
    switch (action) {
      case /* Noop */0 :
          return /* tuple */[
                  state,
                  /* IODoNothing */0
                ];
      case /* Stop */1 :
          return /* tuple */[
                  {
                    durationInput: "",
                    timerStartTime: state.timerStartTime,
                    currentTime: state.currentTime,
                    timeLeft: state.timeLeft,
                    intervalId: state.intervalId
                  },
                  /* IOStopTimer */Block.__(1, [state.intervalId])
                ];
      case /* GetCurrentTime */2 :
          return /* tuple */[
                  state,
                  /* IOGetCurrentTime */1
                ];
      
    }
  } else {
    switch (action.tag | 0) {
      case /* Start */0 :
          return /* tuple */[
                  state,
                  /* IOStartTimer */Block.__(0, [action[0]])
                ];
      case /* SetDuration */1 :
          return setDuration(state, action[0]);
      case /* SetTimer */2 :
          return /* tuple */[
                  {
                    durationInput: state.durationInput,
                    timerStartTime: action[1],
                    currentTime: state.currentTime,
                    timeLeft: state.timeLeft,
                    intervalId: action[0]
                  },
                  /* IODoNothing */0
                ];
      case /* SetCurrentTime */3 :
          return setTimeLeft$1(state, action[0]);
      
    }
  }
}

function startTimer(dispatch) {
  console.log("starting timer...");
  return /* SetTimer */Block.__(2, [
            startClock(dispatch),
            Date.now()
          ]);
}

function isFinished(timeLeft) {
  if (timeLeft !== undefined && timeLeft <= 0.0) {
    return /* Stop */1;
  } else {
    return /* Noop */0;
  }
}

function runEffect(effect) {
  if (typeof effect === "number") {
    if (effect === /* IODoNothing */0) {
      return /* Noop */0;
    } else {
      return /* SetCurrentTime */Block.__(3, [Date.now()]);
    }
  }
  switch (effect.tag | 0) {
    case /* IOStartTimer */0 :
        return startTimer(effect[0]);
    case /* IOStopTimer */1 :
        return /* SetTimer */Block.__(2, [
                  stopClock(effect[0]),
                  undefined
                ]);
    case /* IOCheckIfTimerFinished */2 :
        return isFinished(effect[0]);
    
  }
}

function wrapBusinessLogicWithEffects(f, _state, _action) {
  while(true) {
    var action = _action;
    var state = _state;
    var match = Curry._2(f, state, action);
    var effect = match[1];
    var newState = match[0];
    if (effect === /* IODoNothing */0) {
      return /* tuple */[
              newState,
              /* Noop */0
            ];
    }
    var nextAction = runEffect(effect);
    _action = nextAction;
    _state = newState;
    continue ;
  };
}

var initState = {
  durationInput: "",
  timerStartTime: undefined,
  currentTime: undefined,
  timeLeft: undefined,
  intervalId: undefined
};

export {
  initState ,
  setDuration ,
  timeLeft ,
  calcEndTime ,
  $$Option ,
  startClock ,
  stopClock ,
  setTimeLeft$1 as setTimeLeft,
  businessLogic ,
  startTimer ,
  isFinished ,
  runEffect ,
  wrapBusinessLogicWithEffects ,
  
}
/* No side effect */
