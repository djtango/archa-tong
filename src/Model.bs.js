// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Belt_Option from "bs-platform/lib/es6/belt_Option.js";
import * as Caml_format from "bs-platform/lib/es6/caml_format.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";

function timeLeft(currentTime, endTime) {
  return endTime - currentTime;
}

function calcEndTime(startTime, duration) {
  return startTime + duration;
}

function setTimeLeft(state) {
  var start = Belt_Option.getWithDefault(state.currentTime, state.timerStartTime);
  var end_ = state.timerStartTime + state.durationInput;
  return {
          durationInput: state.durationInput,
          timerStartTime: state.timerStartTime,
          currentTime: state.currentTime,
          timeLeft: end_ - start,
          intervalId: state.intervalId
        };
}

function startClock(dispatch) {
  return Caml_option.some(setInterval((function (param) {
                    return Curry._1(dispatch, /* GetCurrentTime */2);
                  }), 30));
}

function stopClock(intervalId) {
  Belt_Option.map(intervalId, (function (prim) {
          clearInterval(prim);
          
        }));
  
}

function reducer(state, action) {
  console.log("reducer");
  console.log(state);
  console.log(action);
  var newState;
  if (typeof action === "number") {
    switch (action) {
      case /* Noop */0 :
          newState = state;
          break;
      case /* Stop */1 :
          newState = {
            durationInput: -1.0,
            timerStartTime: state.timerStartTime,
            currentTime: state.currentTime,
            timeLeft: state.timeLeft,
            intervalId: stopClock(state.intervalId)
          };
          break;
      case /* GetCurrentTime */2 :
          newState = {
            durationInput: state.durationInput,
            timerStartTime: state.timerStartTime,
            currentTime: Date.now(),
            timeLeft: state.timeLeft,
            intervalId: state.intervalId
          };
          break;
      case /* SetTimeLeft */3 :
          newState = setTimeLeft(state);
          break;
      
    }
  } else {
    newState = action.tag ? ({
          durationInput: Caml_format.caml_float_of_string(action[0]),
          timerStartTime: state.timerStartTime,
          currentTime: state.currentTime,
          timeLeft: state.timeLeft,
          intervalId: state.intervalId
        }) : ({
          durationInput: state.durationInput,
          timerStartTime: Date.now(),
          currentTime: state.currentTime,
          timeLeft: state.timeLeft,
          intervalId: startClock(action[0])
        });
  }
  var newAction;
  newAction = typeof action === "number" ? (
      action === /* GetCurrentTime */2 ? /* SetTimeLeft */3 : /* Noop */0
    ) : (
      action.tag ? /* Noop */0 : /* GetCurrentTime */2
    );
  return /* tuple */[
          newState,
          newAction
        ];
}

function withCoeffect(f, _state, _action) {
  while(true) {
    var action = _action;
    var state = _state;
    var match = Curry._2(f, state, action);
    var nextAction = match[1];
    var newState = match[0];
    if (nextAction === /* Noop */0) {
      return /* tuple */[
              newState,
              /* Noop */0
            ];
    }
    _action = nextAction;
    _state = newState;
    continue ;
  };
}

function greetMore(name) {
  return "Hello " + name;
}

var initState = {
  durationInput: -1.0,
  timerStartTime: -1.0,
  currentTime: undefined,
  timeLeft: undefined,
  intervalId: undefined
};

export {
  timeLeft ,
  calcEndTime ,
  initState ,
  setTimeLeft ,
  startClock ,
  stopClock ,
  reducer ,
  withCoeffect ,
  greetMore ,
  
}
/* No side effect */
